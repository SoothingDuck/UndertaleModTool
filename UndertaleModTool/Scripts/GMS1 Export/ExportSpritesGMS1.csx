// Modified with the help of Agentalex9
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using UndertaleModLib.Util;

EnsureDataLoaded();

// Pour avoir un "." au lieu d'une "," dans les conversion en décimal
System.Globalization.CultureInfo customCulture = (System.Globalization.CultureInfo)
    System.Threading.Thread.CurrentThread.CurrentCulture.Clone();
customCulture.NumberFormat.NumberDecimalSeparator = ".";

System.Threading.Thread.CurrentThread.CurrentCulture = customCulture;

//
// bool padded = (!ScriptQuestion("Export all sprites unpadded?"));

bool padded = true;

string texFolder = GetFolder(FilePath) + "sprites" + Path.DirectorySeparatorChar;
TextureWorker worker = new TextureWorker();
if (Directory.Exists(texFolder))
{
    Directory.Delete(texFolder, true);
}
Directory.CreateDirectory(texFolder);

// layer
string layer_directory = texFolder + "images";
Directory.CreateDirectory(layer_directory);

// Sprites
SetProgressBar(null, "Sprites", 0, Data.Sprites.Count);
StartProgressBarUpdater();

await DumpSprites();

await StopProgressBarUpdater();
HideProgressBar();

// // Backgrounds
// SetProgressBar(null, "Backgrounds", 0, Data.Backgrounds.Count);
// StartProgressBarUpdater();

// await DumpBackgrounds();
// worker.Cleanup();

// await StopProgressBarUpdater();
// HideProgressBar();

// Export asset
using (StreamWriter writer = new StreamWriter(texFolder + "asset_order.txt"))
{
    writer.WriteLine("  <sprites name=\"sprites\">");
    for (int i = 0; i < Data.Sprites.Count; i++)
    {
        UndertaleSprite sprite = Data.Sprites[i];
        writer.WriteLine("    <sprite>sprites\\" + sprite.Name.Content + "</sprite>");
    }
    writer.WriteLine("  </sprites>");
}

ScriptMessage("Export Complete.\n\nLocation: " + texFolder);

// --------------------------------------------------------------------- Functions ---------------------------------------------------------------------------
string GetFolder(string path)
{
    return Path.GetDirectoryName(path) + Path.DirectorySeparatorChar;
}

async Task DumpSprites()
{
    await Task.Run(() => Parallel.ForEach(Data.Sprites, DumpSprite));
}

void DumpSprite(UndertaleSprite sprite)
{
    // BEGIN : Extraction Images
    for (int i = 0; i < sprite.Textures.Count; i++)
    {
        if (sprite.Textures[i]?.Texture != null)
        {
            worker.ExportAsPNG(
                sprite.Textures[i].Texture,
                texFolder
                    + "images"
                    + Path.DirectorySeparatorChar
                    + sprite.Name.Content
                    + "_"
                    + i
                    + ".png",
                null,
                padded
            ); // Include padding to make sprites look neat!

            // // Création du répertoire dans "layers"
            // Directory.CreateDirectory(texFolder + sprite.Name.Content + "\\" + "layers" + "\\" + sprite.Name.Content + "_" + i);

            // // Extraction de l'image "layer"
            // worker.ExportAsPNG(sprite.Textures[i].Texture,texFolder + sprite.Name.Content + "\\" + "layers" + "\\" + sprite.Name.Content + "_"+ i + "\\" + sprite.Name.Content + "_" + "layer" + ".png", null, padded); // Include padding to make sprites look neat!
        }
    }
    // END : Extraction Images

    // Directory.CreateDirectory(texFolder + sprite.Name.Content);
    using (StreamWriter writer = new StreamWriter(texFolder + sprite.Name.Content + ".sprite.gmx"))
    {
        writer.WriteLine(
            "<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->"
        );
        writer.WriteLine("<sprite>");
        writer.WriteLine("  <type>0</type>"); // TODO type ??
        writer.WriteLine("  <xorig>" + sprite.OriginX + "</xorig>");
        writer.WriteLine("  <yorigin>" + sprite.OriginY + "</yorigin>");
        if (sprite.SepMasks == UndertaleSprite.SepMaskType.Precise)
        { // Precise Mask
            writer.WriteLine("  <colkind>0</colkind>");
        }
        else if (sprite.SepMasks == UndertaleSprite.SepMaskType.AxisAlignedRect)
        { // Rectangle Mask
            writer.WriteLine("  <colkind>1</colkind>");
            // } else if(sprite.SepMasks == UndertaleSprite.SepMaskType.Ellipse) { // Ellipse Mask
            //     writer.WriteLine("  <colkind>2</colkind>");
        }
        else if (sprite.SepMasks == UndertaleSprite.SepMaskType.RotatedRect)
        { // Diamond Mask
            writer.WriteLine("  <colkind>3</colkind>");
        }
        else
        {
            writer.WriteLine("  <colkind>4</colkind>");
        }
        writer.WriteLine("  <coltolerance>0</coltolerance>");
        if (sprite.SepMasks == UndertaleSprite.SepMaskType.Precise)
        { // Si Precise alors -1 sinon 0
            writer.WriteLine("  <sepmasks>-1</sepmasks>");
        }
        else
        {
            writer.WriteLine("  <sepmasks>0</sepmasks>");
        }
        writer.WriteLine("  <bboxmode>" + sprite.BBoxMode + "</bboxmode>");
        writer.WriteLine("  <bbox_left>" + sprite.MarginLeft + "</bbox_left>");
        writer.WriteLine("  <bbox_right>" + sprite.MarginRight + "</bbox_right>");
        writer.WriteLine("  <bbox_top>" + sprite.MarginTop + "</bbox_top>");
        writer.WriteLine("  <bbox_bottom>" + sprite.MarginBottom + "</bbox_bottom>");
        writer.WriteLine("  <HTile>0</HTile>");
        writer.WriteLine("  <VTile>0</VTile>");
        writer.WriteLine("  <TextureGroups>");
        writer.WriteLine("    <TextureGroup0>0</TextureGroup0>");
        writer.WriteLine("  </TextureGroups>");
        writer.WriteLine("  <For3D>0</For3D>");
        writer.WriteLine("  <width>" + sprite.Width + "</width>");
        writer.WriteLine("  <height>" + sprite.Height + "</height>");
        writer.WriteLine("  <frames>");
        for (int i = 0; i < sprite.Textures.Count; i++)
        {
            if (sprite.Textures[i]?.Texture != null)
            {
                writer.WriteLine(
                    "    <frame index=\""
                        + i
                        + "\">images\\"
                        + sprite.Name.Content
                        + "_"
                        + i
                        + ".png</frame>"
                );
            }
        }
        writer.WriteLine("  </frames>");
        writer.WriteLine("</sprite>");
    }

    IncrementProgressParallel();
}
