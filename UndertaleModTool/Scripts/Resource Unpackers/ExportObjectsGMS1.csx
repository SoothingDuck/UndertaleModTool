using System.Text;
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;

EnsureDataLoaded();

string objectsFolder = GetFolder(FilePath) + "Export_Objects" + Path.DirectorySeparatorChar;
ThreadLocal<GlobalDecompileContext> DECOMPILE_CONTEXT = new ThreadLocal<GlobalDecompileContext>(() => new GlobalDecompileContext(Data, false));
// if (Directory.Exists(objectsFolder))
// {
//     ScriptError("An object export already exists. Please remove it.", "Error");
//     return;
// }

Directory.CreateDirectory(objectsFolder);

bool exportFromCache = false;
// if (GMLCacheEnabled && Data.GMLCache is not null)
//     exportFromCache = ScriptQuestion("Export from the cache?");

List<UndertaleGameObject> toDump;
if (!exportFromCache)
{
    toDump = new();
    foreach (UndertaleGameObject game_object in Data.GameObjects)
    {
        toDump.Add(game_object);
    }
}

bool cacheGenerated = false;
if (exportFromCache)
{
    cacheGenerated = await GenerateGMLCache(DECOMPILE_CONTEXT);
    await StopProgressBarUpdater();
}

SetProgressBar(null, "Object Entries", 0, exportFromCache ? Data.GMLCache.Count + Data.GMLCacheFailed.Count : toDump.Count);
StartProgressBarUpdater();

await DumpCode();

await StopProgressBarUpdater();
HideProgressBar();
ScriptMessage("Export Complete.\n\nLocation: " + objectsFolder);


string GetFolder(string path)
{
    return Path.GetDirectoryName(path) + Path.DirectorySeparatorChar;
}


async Task DumpCode()
{

    if (Data.KnownSubFunctions is null) //if we run script before opening any code
        Decompiler.BuildSubFunctionCache(Data);

    await Task.Run(() => Parallel.ForEach(toDump, DumpGameObject));
}

void DumpGameObject(UndertaleGameObject game_object)
{
    using (StreamWriter writer = new StreamWriter(objectsFolder + game_object.Name.Content + ".object.gmx"))
    {
        writer.WriteLine("<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->");
        writer.WriteLine("<object>");
        if(game_object.Sprite != null)
        {
            writer.WriteLine("  <spriteName>" + game_object.Sprite.Name.Content + "</spriteName>");
        } else
        {
            writer.WriteLine("  <spriteName>&lt;undefined&gt;</spriteName>");
        }
        writer.WriteLine("  <solid>" + (game_object.Solid ? -1 : 0) + "</solid>");
        writer.WriteLine("  <visible>" + (game_object.Visible ? -1 : 0) + "</visible>");
        writer.WriteLine("  <depth>" + game_object.Depth + "</depth>");
        if (game_object.ParentId != null)
        {
            writer.WriteLine("  <parentName>" + game_object.ParentId.Name.Content + "</parentName>");
        } else
        {
            writer.WriteLine("  <parentName>&lt;undefined&gt;</parentName>");
        }
        if (game_object.TextureMaskId != null)
        {
            writer.WriteLine("  <maskName>" + game_object.TextureMaskId.Name.Content + "</maskName>");
        }
        else
        {
            writer.WriteLine("  <maskName>&lt;undefined&gt;</maskName>");
        }
        writer.WriteLine("  <events>");
        var i = 0;
        foreach (var e1 in game_object.Events)
        {
            foreach (var e2 in e1)
            {
                writer.WriteLine("    <event eventtype=\"" + i + "\" enumb=\"" + e2.EventSubtype + "\">");
                foreach (var a in e2.Actions)
                {
                    writer.WriteLine("      <action>");
                    writer.WriteLine("        <libid>"+ a.LibID + "</libid>");
                    writer.WriteLine("        <id>"+ a.ID + "</id>");
                    writer.WriteLine("        <kind>"+ a.Kind + "</kind>");
                    writer.WriteLine("        <userelative>"+ (a.UseRelative ? -1 : 0) + "</userelative>");
                    writer.WriteLine("        <isquestion>"+ (a.IsQuestion ? -1 : 0) + "</isquestion>");
                    writer.WriteLine("        <useapplyto>"+ (a.UseApplyTo ? -1 : 0) + "</useapplyto>");
                    writer.WriteLine("        <exetype>"+ a.ExeType + "</exetype>");
                    writer.WriteLine("        <functionname></functionname>");
                    writer.WriteLine("        <codestring></codestring>");
                    writer.WriteLine("        <whoName>"+ (a.Who == -1 ? "self" : "") + "</whoName>");
                    writer.WriteLine("        <relative>" + (a.Relative ? -1 : 0) + "</relative>");
                    writer.WriteLine("        <isnot>"+ (a.IsNot ? -1 : 0) + "</isnot>");
                    writer.WriteLine("        <arguments>");
                    writer.WriteLine("        </arguments>");
                    writer.WriteLine("      </action>");
                }
                writer.WriteLine("    </event>");
            }
            i++;
        }
        writer.WriteLine("  </events>");
        writer.WriteLine("  <PhysicsObject>" + (game_object.UsesPhysics ? -1 : 0) + "</PhysicsObject>");
        writer.WriteLine("  <PhysicsObjectSensor>" + (game_object.IsSensor ? -1 : 0) + "</PhysicsObjectSensor>");
        writer.WriteLine("  <PhysicsObjectShape>" + (int) game_object.CollisionShape + "</PhysicsObjectShape>");
        writer.WriteLine("  <PhysicsObjectDensity>" + game_object.Density.ToString("0.00", System.Globalization.CultureInfo.InvariantCulture) + "</PhysicsObjectDensity>");
        writer.WriteLine("  <PhysicsObjectRestitution>" + game_object.Restitution.ToString("0.00", System.Globalization.CultureInfo.InvariantCulture) + "</PhysicsObjectRestitution>");
        writer.WriteLine("  <PhysicsObjectGroup>" + game_object.Group + "</PhysicsObjectGroup>");
        writer.WriteLine("  <PhysicsObjectLinearDamping>" + game_object.LinearDamping.ToString("0.00", System.Globalization.CultureInfo.InvariantCulture) + "</PhysicsObjectLinearDamping>");
        writer.WriteLine("  <PhysicsObjectAngularDamping>" + game_object.AngularDamping.ToString("0.00", System.Globalization.CultureInfo.InvariantCulture) + "</PhysicsObjectAngularDamping>");
        writer.WriteLine("  <PhysicsObjectFriction>" + game_object.Friction.ToString("0.00", System.Globalization.CultureInfo.InvariantCulture) + "</PhysicsObjectFriction>");
        writer.WriteLine("  <PhysicsObjectAwake>" + (game_object.Awake ? -1 : 0) + "</PhysicsObjectAwake>");
        writer.WriteLine("  <PhysicsObjectKinematic>" + (game_object.Kinematic ? -1 : 0) + "</PhysicsObjectKinematic>");
        writer.WriteLine("  <PhysicsShapePoints/>");
        writer.WriteLine("</object>");

    }

    //     if (code is not null)
    //     {
    //         if(code.Name.Content.Contains("gml_Script_")) {
    //             string path = Path.Combine(objectsFolder, code.Name.Content.Substring(11) + ".gml");
    //             try
    //             {
    //                 File.WriteAllText(path, (code != null ? Decompiler.Decompile(code, DECOMPILE_CONTEXT.Value) : ""));
    //             }
    //             catch (Exception e)
    //             {
    //                 File.WriteAllText(path, "/*\nDECOMPILER FAILED!\n\n" + e.ToString() + "\n*/");
    //             }        
    //         }
    //     }

    IncrementProgressParallel();
}
void DumpCachedCode(KeyValuePair<string, string> code)
{
    string path = Path.Combine(objectsFolder, code.Key + ".gml");

    File.WriteAllText(path, code.Value);

    IncrementProgressParallel();
}